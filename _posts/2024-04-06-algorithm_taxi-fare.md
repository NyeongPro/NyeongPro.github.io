---
layout: single
title:  "[Algorithm]프로그래머스 합승 택시 요금 문제[파이썬 Python]"
categories: algorithm
tag: [algorithm, 코테, 코딩테스트, 파이썬, python]
redirect_from:
  - /algorithm/algorithm_taxi-fare
---

# [합승 택시 요금] 문제
## 코드
```python
import sys, heapq
def solution(n, s, a, b, fares):
    answer = 0
    
    # 1) INF 사이즈 설정하기
    INF = int(1e9)
    
    # 2) 가능한 모든 간선에 대해 저장
    edges = [[] for _ in range(n+1)]
    for u, v, cost in fares:
        edges[u].append((v, cost))
        edges[v].append((u, cost))
    
    def dijkstra(start):
        # 3) distance INF로 설정
        distance = [INF] * (n+1)
        
        # 4) 초기 설정
        distance[start] = 0
        q = []
        heapq.heappush(q, (0, start))
        
        while q:
            cur_dist, cur_node = heapq.heappop(q)
            
            # 5) 거리 비교
            if distance[cur_node] < cur_dist:
                continue
            
            for next_node, next_dist in edges[cur_node]:
                if distance[next_node] > cur_dist + next_dist:
                    distance[next_node] = cur_dist + next_dist
                    heapq.heappush(q, (cur_dist + next_dist, next_node))
        
        return distance
    
    # 6) 두 명이 합승해서 가는 비용
    D = [0] + [dijkstra(i) for i in range(1, n+1)]
    print(D)
    min_cost = INF
    for i in range(1, n+1):
        min_cost = min(min_cost, D[s][i] + D[i][a] + D[i][b])
    
    return min_cost
```
## 풀이

다익스트라를 통해 풀었습니다.  

먼저 다익스트라 알고리즘에 대해서 알아보겠습니다.

주로 **어느 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야하는 경우**, **모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우** 에 사용합니다.

그래프에서 여러 개의 노드가 있을 때, 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해줍니다.

이 알고리즘의 순서는 아래와 같습니다.

1. 출발 노드 설정
2. 최단 거리 테이블을 무한(int(1e9) or sys.maxsize 등)로 초기화한다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하고 최단 거리 테이블을 갱신
5. 3, 4 과정을 반복

Heapq를 사용하는 다익스트라의 효율이 좋으니 이를 살펴보겠습니다.

### 1) INF 사이즈 설정하기
무한대 값으로 사용할 INF 값을 설정합니다.
```python
INF = int(1e9)
```
위 코드를 사용하기도 합니다.

문제 조건에서 요금 f 가 100,000 이하 자연수라 주어졌으니 이 값보다 크면 됩니다.

### 2) 가능한 모든 간선에 대해 저장
이 간선 저장하는 것은 그래프로 연결된 BFS에서도 많이 사용하니 익히는 게 중요한 것 같아요.

미리 간선을 저장할 리스트를 노드의 개수+1개 만큼 설정합니다.

이는 1번 노드에 1번 인덱스로 접근하기 위함입니다.

만약 n개의 리스트로 만든다면, 1번 노드를 접근할 때 0번 인덱스로 접근해야하니
많이 불편하게 됩니다. 따라서 n번 노드를 접근할 때 n번 인덱스를 사용하기 위해 이 같이 리스트를 미리 만듭니다.

여기에 append를 통해 저장해줍니다.  
n번 노드에서 갈 수 있는 모드 노드들과 그때의 비용들을 모두 저장해줍니다.

### 3) distance INF로 설정
distance 리스트를 만들고 n+1개 만큼 INF로 설정합니다.

아래에서 최소 거리를 측정할 때 이 distance 값보다 작으면 갱신할 것이기 때문에
처음에 INF를 설정하여 첫 값이 들어오면 INF보다 클 수 없기 때문에 갱신될 것입니다.

이를 통해 처음 접근한 노드에 대해서 방문이 됐는지 그리고 새로 이동한 path가 이동 거리가 더 짧고 효율적임을 알 수 있게 됩니다.

### 4) 초기 설정
다익스트라는 어디서 출발할지 정하고 모든 노드들에 대해 최대 효율을 낼 수 있는(또는 최소 비용으로 갈 수 있는)길을 안내해줍니다.

그리고 처음 시작 노드에서 처음 시작노드를 가는 비용은 당연히 0이므로 0으로 초기화해줍니다.

그리고 heap으로 사용할 리스트 q를 선언해줍니다.

그리고 heapq.heappush 를 통해 처음에 거리(비용)과 시작점을 추가해줍니다.

### 5) 거리 비교
BFS처럼 시작점(start)에서 모든 노드들의 최소 비용들을 점점 확장해나갑니다.

그래서 만약 1에서 2를 갈 수 있었다면 1에서 2를 가는 비용이 distance[2]에 저장됩니다.

그런데 1에서 출발해서 어딘가를 경유하여 2를 도착하니 1에서 2로 바로 가는 것보다 효율이 더 좋으면
당연히 이를 갱신해줘야겠죠?

이때 if 절과 for 루프에서 이를 담당합니다.

if 절은 위에서 설명드린 예시의 반대입니다.

"distance[2]에 저장된 게 지금 현재 비용(cur_dist)보다 작아~" 라고 한다면
굳이 갱신할 이유가 없죠?

distance[2]는 1에서 2로 갈 수 있는 모든 경우를 대체할 수 있습니다.

1-2 / 1-3-2 / 1-5-4-2 와 같은 모든 경우에 대해서 이 중에서 제일 최소로 갈 수 있는 경로를 매번 갱신하기 때문에

모든 노드들을 탐색하고 나서 1-5-4-2가 제일 최소였을 수 있겠죠. 이 값이 저장되있을 겁니다.

그래서 while 루프가 모두 끝나면 이 distance에 어떤 경로를 통해서 갔든지간에, 시작점에서 어느 지점으로 가는 거리 중 제일 최소!
를 저장할 수 있습니다.

다시 정리하면, if 절에서는 이전에 distance에 어떤 경로를 통해서 간 제일 최소 경로를 저장해두었어, 근데 그 경로값보다 cur_dist가 더 효율적이니?
라고 묻는 것입니다.

if 절을 들어간다면, cur_dist가 큰 것이니, 더 효율적이지 못했다고 판단한 거겠네요. 그러면 굳이 갱신할 이유가 없습니다.

그리고 아래에서 for 루프가 동작합니다.
이곳을 왔다는 것은 더 효율적인 길을 찾았다는 뜻이죠, continue를 건너왔으니까요.

그래서 현재 노드에서 간선으로 연결돼서 갈 수 있는 모든 경우에 대해 탐색합니다.

```python
for next_node, next_dist in edges[cur_node]:
```
위를 보시면 지금 현재 노드에서 갈 수 있는 모든 간선을 저장한 edges에서 요소들을 하나씩 받아옵니다.

만약 현재 노드가 4였다면, edges에는 (2, 66) / (6, 50) 이 저장되어있겠네요.

이는 2번 노드로 갈 수 있고, 비용은 66이야. / 6번 노드로 갈 수 있고, 비용은 50이야. 라는 뜻입니다.

그래서 4번 노드에서 2번 노드와 6번 노드를 간 경우에 대해서 비용의 효율을 따지게 됩니다.

그리고 따지는 법은 간단합니다. 

다음 노드로 가는 제일 효율적인 방법(distance[next_node]) 하고 지금까지 비용(cur_dist)에 다음 노드로 건너갈 때 드는 비용 next_dist를 합친 값중에
어디가 더 효율적이니? 라고 묻는 겁니다.

만약 지금까지 왔던 비용하고 다음 노드로 갔던 비용을 합친게, 즉 아까 어느 경로로 갔던지간에 제일 효율적이었던 distance값보다
지금 이동할 때 드는 비용이 더 효율적이라면 if 절로 들어갑니다.

그리고 비용을 갱신해주면 되죠. 그리고 BFS처럼 다음 경로에 대해 다시 push를 해주고 그 노드에서 또 효율적인 노드에 대해 지속적으로 탐색합니다.

### 6) 두 명이 합승해서 가는 비용
D를 출력해보면 아래와 같습니다.

```python
[0, [1000000000, 0, 63, 41, 10, 24, 25], [1000000000, 63, 0, 22, 66, 46, 48], [1000000000, 41, 22, 0, 51, 24, 26], [1000000000, 10, 66, 51, 0, 34, 35], [1000000000, 24, 46, 24, 34, 0, 2], [1000000000, 25, 48, 26, 35, 2, 0]]
```

D[a][b] 뜻은 a에서 b를 갈 때 제일 적게 드는 값입니다.

즉 D[1][3]은 1번 노드에서 출발해서 3번 노드로 갈 때 제일 효율적인 값이 뭐야? 라고 묻는것이죠.

그래서 D[1][3]값을 보면 41입니다. 문제 예시에서 보면 1-3으로 바로 갈 때 41 비용이 듭니다.
이것은 최소가 되는 비용인 것을 알 수 있습니다.

dijkstra 알고리즘이 제대로 작동하는 것을 확인할 수 있습니다.

D를 선언할 때 [0] 을 추가한 것은 위에서도 설명드렸다시피, n번 노드에 접근할 때 n번 인덱스를 사용하기 위함입니다.

D[0]에 대해서는 0번 노드가 없기 때문에 0이고, 다른 노드들이 인덱스가 -1이 되는 것을 방지합니다.

또한 D[1][0]을 보시면 1번 노드에서 0번을 가는 경우인데 이는 INF 값으로 갈 수 없는 경로가 됩니다.

즉 INF값인 경우 어떠한 방법으로도 그곳을 갈 수 없다는 뜻이죠.


이제 저 D를 활용해보겠습니다.

문제 요구사항으로 어느 지점까지는 합승하다가 각자 택시를 나눠져서 타고 목적지에 갑니다.

따라서 S노드에서 I노드까지 합승 -> "무지"는 I노드에서 A노드까지, "어피치"는 I노드에서 B노드 까지 입니다.

그래서 I 노드를 모든 노드에 대해서 조사합니다.

S 노드는 정해져있고, I를 모든 노드에 대해서 조사하면 어디까지 합승하고 나눠지는 지 모든 경우에 대해 조사할 수 있습니다.

따라서 아래와 같이 식을 정리할 수 있습니다.

```
D[s][i] + D[i][a] + D[i][b]
```

이렇게 하면 s에서 i까지 최소로 갈 수 있습니다. 그리고 한 명은 i에서 a까지 최소로 가는 경우 + 다른 한 명은 i에서 b까지 최소로 가는 경우

위 모두를 최소값으로 구할 수 있습니다.

그리고 최종적으로 모든 i에 대해서 제일 최소값을 구해야하기 때문에 min 함수를 사용하여 최종값을 구하게 됩니다.

# 참고 사이트

[파이썬 다익스트라 2가지 방법으로 구현 (for, heapq)](https://week-book.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-2%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84-for-heapq)  

[[프로그래머스 LV 3] 합승 택시요금 (파이썬/python)](https://foameraserblue.tistory.com/192)  
