---
layout: single
title:  "[Algorithm]프로그래머스 전력망을 둘로 나누기 문제[파이썬 Python]"
categories: algorithm
tag: [algorithm, 코테, 코딩테스트, 파이썬, python]
redirect_from:
  - /algorithm/algorithmkit15
---

# [전력망을 둘로 나누기] 문제
## 코드
```python
from collections import deque
from copy import deepcopy

def connect(n, edges):
    queue = deque()
    visited = [False for _ in range(n+1)]
    
    queue.append(edges[1])
    visited[1] = True
    while queue:
        nextNodes = queue.popleft()  # 방문할 곳이 들어있는 리스트
        for nowNode in nextNodes:
            if not visited[nowNode]:
                visited[nowNode] = True
                queue.append(edges[nowNode])
            
    return visited.count(True)
        
    
def solution(n, wires):
    edges = [[] for _ in range(n+1)]
    
    for edge in wires:
        x, y = edge
        edges[x].append(y)
        edges[y].append(x)
    minList = []
    for i in range(n-1):
        removeEdges = deepcopy(edges)
        
        # x, y 전선을 제거 했다고 가정
        x, y = wires.pop()
        removeEdges[x].remove(y)
        removeEdges[y].remove(x)
        result = connect(n, removeEdges)
        minList.append(abs((n-result)-result))
        
    return min(minList)
```
## 풀이
### 1) 간선 리스트 만들기
만약 1번 노드에 3, 4, 5 가 연결되어 있다면 
edges[1] 에 [3, 4, 5] 가 저장되도록 했습니다.
그래서 리스트만 보고 연결된 곳으로 쉽게 접근할 수 있도록 했습니다.

### 2) 깊은 복사
파이썬에서는 얕은 복사와 깊은 복사의 개념이 있습니다.  

만약 list1 = [1, 2, 3], list2 = [] 이렇게 두 개의 리스트가 있다고 가정하겠습니다. 
그러면 list2 = list1을 수행하면 어떻게 될까요?

print(list2)를 해보면 [1, 2, 3]이 출력되는것을 확인할 수 있습니다. 복사가 잘 된 것이죠.
하지만 문제가 생깁니다.

list1을 한참 수정하고나서, list2를 출력해보니 list2도 같이 수정된 것이죠.
list1의 복사본을 만들어두고 싶었거나 list1만 수정하고 list2는 그대로 두고 싶었지만,
list2도 list1 수정에 영향을 받았습니다...

이는 mutable 한 객체인 list, set, dictionary에 모두 이런 현상이 적용됩니다.
c언어를 배우셨으면 금방 이해하실텐데 사실 mutable 한 객체를 단순히 = 연산자로 복사하면
안에 값만 딸랑 복사되고 끝나는 것이 아니라 같은 객체를 가리키게 돼서 값이 복사가 되는 것처럼 보이는 것입니다.

즉 10이라는 주소에 [1, 2, 3] 이라는 list1 객체가 저장되어 있다면, list2 = list1을 하게되면
list1의 값들을 독립된 list2에 적어주는게 아니라 list2도 그냥 list1의 주소 10인 곳을 가리키게 되는것뿐입니다.

따라서 이를 해결하기 위해서는 파이썬의 deepcopy를 사용해서 독립된 리스트에 값만 복사해주는 깊은 복사를 사용해야합니다.
이에 대한 정보는 [여기](https://blockdmask.tistory.com/576)에 자세하게 설명되어 있으니 mutable한 객체에 대해 얕은 복사가 이해가 안되시면 보면 좋을 것 같아요.

저는 이제 깊은 복사 함수를 사용해보겠습니다.
먼저 copy 라이브러리에서 deepcopy를 추가해야합니다.
```python
from copy import deepcopy
```
위의 코드를 통해 추가했습니다.

그리고 removeEdges라는 리스트에 edges를 깊은 복사하겠습니다.  

이제 removeEdges를 아무리 수정해도 edges는 그대로 남아있을 수 있겠네요.
깊은 복사를 했기 때문입니다.

### 3) 한 전선을 제거
이제 n-1개의 전선을 번갈아가면서 하나씩 제거해봅니다.  
wires.pop(0)을 하면 0번 인덱스를 뽑고 나머지 존재하는 것들의 인덱스도 조절해야해서
시간이 오래 걸리기 때문에 pop()을 그냥 사용했습니다.  

어차피 어디서부터 뽑든 모든 전선을 제거해봐야 알 수 있는 것이니까요.

그리고 전선 하나를 뽑고 x, y로 받았습니다. 이제 removeEdges에서 이 전선을 제거해봅니다.

그러면 removeEdges는 이 전선이 제거된 edges가 됩니다.
예를 들어 아래에서 전선이 제거, 제거되지 않은 리스트를 보여드리겠습니다.
```python
# 제거되기전 리스트
[[], [3], [3], [1, 2, 4], [3, 5, 6, 7], [4], [4], [4, 8, 9], [7], [7]]

# [7, 9] 전선 제거후 리스트
[[], [3], [3], [1, 2, 4], [3, 5, 6, 7], [4], [4], [4, 8], [7], []]
```
위의 예시를 보시면 7번 인덱스의 9번이 빠지고, 9번 인덱스에서 7번이 빠졌습니다.
7번이 9번과 연결되지 않았다는 뜻이고, 9번도 7번과 연결이 끊어졌다는 뜻입니다.

### 4) deque와 방문 기록 리스트
deque를 이용해 1번 노드부터 연결된 모든 노드들에 방문표시를 할겁니다.
visited는 True, False를 통해 방문했는지 안했는지 표시합니다.

> **어디가 끊어졌고 어떻게 연결되어 있는지 모르는데 1번 노드부터 연결된 노드만 확인하는 이유?**  
> 
> 제가 고민하면서 생각해낸 꼼수라고 해야할까요? 문제에서 n개의 노드가 있다고 주어졌습니다.
> 그리고 1번노드에서 연결된 모든 노드들의 개수를 예를 들어 4개라고 해볼게요.
> 그러면 자동으로 1번노드쪽에서 연결되지 않은 노드들은 5개가 됩니다.
> 한쪽에서 연결되지 않았다면 다른쪽에서 다 연결되어있을테니까요. 9-4 = 5개가 말이죠.
> 이게 가능한 이유는 노드 n개를 문제에서 지정해주고, 처음 전선을 끊기전 n개의 노드들은 단 하나의 트리만을 구성하고 있다는 것이 특징입니다.
> 또한 하나의 전선을 끊어서 두 개의 전력망만을 만든다고 문제에서 제한해두었기 때문에 가능한 풀이겠네요.

### 5) 1번노드와의 연결 확인
이제 queue에 1번 노드를 append하고 1번 노드를 방문했다고 표시합니다.

그리고 while 문을 통해 1번 노드에 연결된 모든 노드들을 append하면서 visited를 True로 바꾸면 됩니다.
append를 계속 계속하면서 연결된 노드들을 하나씩 확장한다고 생각하면 되겠네요.

그리고 1번 노드에서 연결된 방문 노드들은 전부 True로 변경되어있으니, True의 개수를 세주면 1번 노드에서 연결된 노드들의 개수를 확인할 수 있습니다.

### 6) 1번노드에 연결된 노드 수로 계산
이제 1번 노드와 연결된 노드의 총 수를 result에 할당했습니다.
그리고 두 전력망의 개수의 차는 절댓값( (n-result) - result) 입니다.
한 전력망, 즉 1번 노드와 연결된 쪽의 전력망의 노드 개수는 result 이고,
다른 전력망, 즉 1번 노드와 연결되지 않은 쪽의 전력망의 노드 개수는 n-result입니다. 

따라서 두 전력망의 차는 절댓값( (n-result) - result) 입니다.
그리고 파이썬에서 절댓값은 abs()입니다.
절댓값의 영어가 absolute value 라서 그런 것 같네요.

이제 한 전선을 없앴을 때 두 전력망의 차이를 모두 모아서 그 중에서 min 값을 취해주면 답이 됩니다.

## 추가

### 다른 풀이

#### 코드
```python
def solution(n, wires):
    ans = n
    for sub in (wires[i+1:] + wires[:i] for i in range(len(wires))):
        s = set(sub[0])
        [s.update(v) for _ in sub for v in sub if set(v) & s]  # 집합연산자 & : 교집합 연산,   집합연산자 update : 여러데이터를 한번에 추가
        ans = min(ans, abs(2 * len(s) - n))
    return ans
```
> * slice를 이용해 리스트 한 칸씩 비우기  
> `wires[i+1:] + wires[:i] for i in range(len(wires))` 를 통해서 리스트에서 한 칸씩 이동하며 한 칸을 비우게 자르는 것을 이 방법으로 가능하다는 것을 알았다.  
>
> i = 0 / wires[1:] + wires[:0] -> 첫 번째 칸 비움    
> i = 1 / wires[2:] + wires[:1] -> 세 번째 칸부터 끝까지 + 첫 번째 칸 -> 두 번째 칸 비움    
>
> 위와 같이 slice를 하면 i에 따라 한 칸씩 비우면서 합칠 수 있다.

위의 코드도 제가 생각한 개념과 완전히 같은 것 같아요.  

일단 wires에서 한 칸 제거한 리스트를 sub로 둡니다. 그럼 이 sub는 한 wire만 끊어진 list겠네요.
그리고 sub[0]을 집합 s로 둡니다. 이제 밑에 코드를 간단히 설명하면 sub[0]에 들어있는 노드와 연결된 모든 wire들을 전부 합쳐서 
abs(2 * len(s) - n)) 합니다. 이제 이것들을 min 함수를 이용해서 for 루프를 도는 동안 계속해서 최솟값을 찾아내고
그 값을 return 합니다.

그렇다면 왜 `[s.update(v) for _ in sub for v in sub if set(v) & s]` 이 코드가 첫 sub[0]에 들어있는 노드와 연결된 모든 wire를 찾는
코드일까요?

저 부분을 들여쓰기를 통해 보기 편하도록 바꾸면 아래 코드와 같습니다.
```python
for _ in sub:
  for v in sub:
    if set(v) & s:
      s.update(v)     
```
이 4줄을 한 줄로 바꾸면 `[s.update(v) for _ in sub for v in sub if set(v) & s]` 가 됩니다.
아직까지 실력이 안돼서 들여쓰기를 써서 표현하는 것이 더 편하고 보기에 잘 들어오네요...  

아무튼 4줄짜리 코드로 설명을 해보겠습니다.
먼저 집합의 교집합을 알아야합니다.

집합 a 가 {1, 2, 3}이고 집합 b가 {3, 4, 5}라고 가정하겠습니다.
이 둘을 교집합 a & b 를 하면 {3}이 나오게 됩니다.
공통 요소를 뽑아오는 것이죠.

그래서 if set(v) & s: 부분을 해석하자면,  
v를 집합으로 만들고 그 집합과 s를 교집합한 값이 존재하니? 라고 묻는 것입니다.
즉 둘 사이의 공통 요소가 하나라도 있었다면 if 조건에 충족하여 구문 안으로 들어갑니다.
그래서 s.update(v)를 합니다.

여기서 update는 여러 요소를 한 번에 넣는 작업입니다.  

집합에 한 요소를 넣으려면 add를 사용해야합니다.
`a.add(1)` 와 같이 말이죠.   
이 add를 여러 번 해야할 때 update를 사용하는 것입니다.  
`a.update([1, 2])`와 같이 말이죠.

즉 저 if절을 다시 한 번 해석하면 아래와 같습니다.
* v라는 리스트가 있는데, 이걸 집합으로 바꾼다.
* 바꾼 집합과 s 집합이 공통된 요소가 하나라도 있니?
* 있다면 s 집합에 v 요소를 전부 add해줘!

즉 v 리스트와 집합 s에서 공통된 요소를 집합 s에 모조리 넣는 것이네요.

그것을 sub의 모든 요소들에 대해 수행합니다.

여기서 for _ in sub: 를 통해 큰 for 루프를 한 번 더 돕니다.
저도 이게 처음에 이해가 잘 안됐습니다.
왜냐하면 이 구문을 지워도 기본 3개의 테스트 케이스는 통과하거든요.
하지만 빼고 제출해보면 실패가 뜹니다...

좀 더 고민해보니 현재 주어진 wires 입력 예시가 잘 정렬되어 있어서 통과한 것이네요.

아래 테스트 케이스 입력을 넣으면 바로 실패합니다.  
n : 6  
wires : [[1, 4], [3, 6], [2, 5], [1, 5], [3, 5]]    
return : 2  

이유를 설명드리자면 한 번의 루프로는 뒤늦게 연결된 wire를 찾을 수 없기 때문입니다.

위의 테케를 통해 살펴볼게요.  

처음에는 wires의 첫 번째 인덱스를 제거한, 즉 [1, 4]를 제거한 sub를 받겠죠?
이 때 sub는 [[3, 6], [2, 5], [1, 5], [3, 5]] 일거에요.
이 상태에서 아래 코드로 출력을 찍어볼게요.
```python
def solution(n, wires):
    ans = n
    for sub in (wires[i+1:] + wires[:i] for i in range(len(wires))):
        s = set(sub[0])
        # [s.update(v) for _ in sub for v in sub if set(v) & s]
        print("sub =", sub)
        print("s =", s)
        for v in sub:
            print("이번에 비교할 v =", v)
            if set(v) & s:
                s.update(v)
            print("업데이트 이후 s =", s)
            print("-----------------------------")
          
        print("최종 업데이트 이후 집합 s =", s)
        ans = min(ans, abs(2 * len(s) - n))

    return ans
```
```
sub = [[3, 6], [2, 5], [1, 5], [3, 5]]
s = {3, 6}
이번에 비교할 v = [3, 6]
업데이트 이후 s = {3, 6}
-----------------------------
이번에 비교할 v = [2, 5]
업데이트 이후 s = {3, 6}
-----------------------------
이번에 비교할 v = [1, 5]
업데이트 이후 s = {3, 6}
-----------------------------
이번에 비교할 v = [3, 5]
업데이트 이후 s = {3, 5, 6}
-----------------------------
최종 업데이트 이후 집합 s = {3, 5, 6}
```
하나의 loop에서 출력이 이렇게 나옵니다.  
저희는 sub[0], [3,6] wire를 가진 3, 6 노드와 연결된 모든 노드들을 찾기 위해 교집합 연산자를 사용했었죠?
그래서 3, 6 노드들과 연결된 모든 노드를 찍으면 결과적으로 s ={1, 2, 3, 5, 6} 이 나와야해요.
1-4 사이 전선만 끊었기 때문이죠.
한 전력망은 {1, 2, 3, 5, 6} 이 나와야 하고,  다른 전력망은 {4} 만 나와서 s 는 결과적으로 s ={1, 2, 3, 5, 6} 가 나와야 하는거죠.

근데 결과를 보면 {3, 5, 6}만 연결됐다고 나오네요? 
위에서 말씀드렸다시피 정렬이 되어있지 않아서 뒤늦게 연결된 wire가 연결된지 확인을 못해서 그렇습니다.  

위 출력을 하나씩 자세히 살펴볼게요.  
먼저 처음 비교해볼 sub는 [[3, 6], [2, 5], [1, 5], [3, 5]] 입니다.  
이는 [1, 4]를 제거한 sub입니다.  

그리고 s는 sub[0]이므로 [3, 6]이 됐네요.
그리고 이번에 비교할 v는 [3, 6]으로 본인이네요. 그래서 업데이트해도 같습니다.  

다음으로 비교할 v는 [2, 5] 입니다. 아쉽게도 [3, 6]과 전혀 연결점이 없네요? 교집합으로 아무것도 나오지 않았기 때문입니다.  
**그렇다면 [2, 5]는 [3, 6]과 아무런 관련이 없을까요?**

그렇지 않습니다. 그림을 그려보면 [3, 6]에 있는 3과 6 노드는 따라가다보면 2, 5노드를 만나게 됩니다.
일단 지금은 연관이 없다고 치고 넘어가볼게요. 이후에 혹시 연결될 수도 있으니까요.

다음으로 비교할 v는 [1, 5]입니다. 이번에도 s는 [3, 6]이므로 연관이 없다고 나오네요.
물론 결과적으로는 연관이 있지만 말이에요.

다음으로 비교할 v는 [3, 5]입니다. 드디어 3이 공통 요소이므로 이번 v를 전부 update하겠네요.
그래서 s가 [3, 5, 6]이 됩니다.

그리고 for 루프가 끝나게됩니다.

이상하죠? 사실 연결이 되어야 하는 노드들이 연결이 안됐어요.
그래서 for 루프를 sub만큼 한 번 더 돌리는겁니다.  
s가 {3, 5, 6}일 때 또 공통 요소를 찾아보면 계속계속 연결지을 수 있거든요.
아까는 5 요소가 없었기에 [1, 5], [2, 5]와 연결이 없다고 판단했지만 이제는 다르겠네요.
5요소가 집합 s에 있으니까요.
이래서 for 루프를 한 번 더 돌렸던 것입니다.

> 스스로 한 줄 한 줄 고민하면서 풀어보니 집합 관계나 교집합 등 어떻게 쓰는지 좀 알 것 같습니다.
> 하지만 이 문제에서 교집합을 쓰면 코드는 깔끔해보일지언정 for 루프를 3중으로 사용하기 때문에 오히려
> 시간 복잡도는 올라가서 BFS보다 결과를 얻기까지 시간이 더 오래걸립니다.
> 그래서 이 문제에서 서로 연결된 노드들 찾는 문제는 BFS를 쓰거나 중간에 루프를 중단시킬 수 있는 장치가 더 필요할 거 같아요.

# 참고 사이트
[[python] 파이썬 얕은복사, 깊은복사 (copy, deepcopy, [:], =) 총 정리](https://blockdmask.tistory.com/576)  

[[프로그래머스]level2-전력망을 둘로 나누기-Python[파이썬]](https://velog.io/@s2ul2/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4level2-%EC%A0%84%EB%A0%A5%EB%A7%9D%EC%9D%84-%EB%91%98%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0-Python%ED%8C%8C%EC%9D%B4%EC%8D%AC)  


