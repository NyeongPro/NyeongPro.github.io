---
layout: single
title:  "[Algorithm]프로그래머스 하노이의 탑 문제[파이썬 Python]"
categories: algorithm
tag: [algorithm, 코테, 코딩테스트, 파이썬, python]
redirect_from:
  - /algorithm/algorithmkit11
---

# [하노이의 탑] 문제
## 코드
```python
def solution(n):
    answer = []
    
    def hanoi(n, start, end, via):
        
        if n == 1:
            answer.append([start, end])
            return 
        
        hanoi(n-1, start, via, end)
        answer.append([start, end])
        hanoi(n-1, via, end, start)
    hanoi(n, 1, 3, 2)
    return answer
```
## 풀이
전혀 감이 안잡혀서 블로그를 참고했네요.  

처음에 최소 횟수가 가능하도록 메모를 하면서 풀어봤을 때 아래와 같은 규칙이 있었습니다.

1번 경우) 4를 3번에 두려면 123이 2번에 있어야한다.  
2번 경우) 3이 2번에 있으려면 12가 3번에 있어야한다.  
3번 경우) 2를 3번에 두려면 1이 2번에 있어야한다.  

숫자로 표현하면 아래와 같았습니다.(오른쪽 숫자부터 쌓여서 왼쪽으로 쌓아져 있는 형태입니다.)  

1 2 3 4  1번탑    
0 0 0 0  2번탑  
0 0 0 0  3번탑  
------------------ 3번 경우    
0 2 3 4  
0 0 0 1  
0 0 0 0  
------------------ 2번 경우  
0 0 3 4  
0 0 0 1  
0 0 0 2  
  
0 0 3 4  
0 0 0 0  
0 0 1 2  
------------------ 1번 경우  
0 0 0 4  
0 0 0 3  
0 0 1 2  
  
0 0 1 4  
0 0 0 3  
0 0 0 2  
  
0 0 1 4  
0 0 2 3  
0 0 0 0  
  
0 0 0 4  
0 1 2 3  
0 0 0 0  
   
숫자를 차근차근 쌓다보니 3을 움직이려면 2에 대해 미리 작업을 쳐두어야합니다.

또한 4를 움직이려면 3까지 123을 만들어두어야 4를 움직일 수 있습니다.  

이처럼 n-1에 대해 미리 작업을 해두어야 n을 움직일 수 있고 또한 기가막히게

1, 2, 4, 8 번의 움직임이 필요했습니다...

그래서 2^n 꼴로 횟수가 증가하는구나라고 생각했습니다.  

그리고 n번째 경우를 만들 때 n-1의 경우를 생각하기 보다  
2를 먼저 만들어두고, 3을 만들고, 4를 만들고 라고 생각해서
n, n+1, n+2 처럼 생각했습니다. 
그래서 DFS로 한 깊이씩 증가시키면서 같은 루틴을 동작시키려 시도했습니다만...
실패했습니다.

결과적으로 n, n-1, n-2, ... 처럼 재귀함수를 사용하는 것이였군요.  

또한 재귀함수를 사용하면서도 함수가 말하는 것이 이해는 되었지만,
실제로 코드를 보지 않고 직접 작성하려고 해보니 매우 어렵게 느껴졌습니다.  

역시 재귀함수를 이용해서 푸는 것은 어렵네요.  

n, n-1, n-2 와 같이 높은 차원의 문제를 해결하기 위해 한 단계 낮은 차원을 사용한다면 재귀함수를 생각해보자.
{: .notice--success}
