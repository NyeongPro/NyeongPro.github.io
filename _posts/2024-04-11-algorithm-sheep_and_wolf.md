---
layout: single
title:  "[Algorithm]프로그래머스 양과 늑대 문제[파이썬 Python]"
categories: algorithm
tag: [algorithm, 코테, 코딩테스트, 파이썬, python]
redirect_from:
  - /algorithm/algorithm-sheep_and_wolf
---

# [양과 늑대] 문제
## 코드
```python
def solution(info, edges):
    answer = 0
    
    N = len(info)
    
    # 모든 경우 체크
    allcase = [[] for _ in range(N)]
    # 초기 설정
    allcase[0] = [[0]]
    
    # 1) 상위 노드에서 하위 노드 갈 수 있는 경로 체크
    edgeInfo = [[] for _ in range(N)]
    for top, bottom in edges:
        edgeInfo[top].append(bottom)
    
    
    for i in range(1, N):
        
        # 2) allcase에서 하나의 경우씩 뽑아옴
        for case in allcase[i-1]:  # ex) allcase : [[0, 1], [0, 8]]
            if i == 3:
                print(allcase)
            # 3) case에서 node 번호를 뽑아옴
            for node in case:  # ex) case : [0, 1]
                possibleNode = edgeInfo[node]  # node = 0 -> possibleNode = [1, 8] / node = 1 -> possibelNode = [2, 4]
                
                # 4) 다음에 갈 수 있는 노드들
                for nextNode in possibleNode:  # possibleNode = [1, 8]
                    
                    # 5) 늑대의 수 때문에 불가능한 경우 미리 제외
                    if nextNode not in case:
                        
                        # 얕은 복사 피하기
                        tmp = []
                        for x in case:
                            tmp.append(x)
                            
                        # 다음 갈 노드 append 하기
                        tmp.append(nextNode)
                        
                        # 양과 늑대의 수를 통해 가능한지 불가능한지 따짐
                        sheep = 0
                        wolf = 0
                        check = False
                        for x in tmp:
                            if info[x] == 0:
                                sheep += 1
                            else:
                                wolf += 1
                            
                            # 경로 종료, 그리고 양의 최대 수 갱신.
                            if sheep == wolf:
                                answer = max(answer, sheep)
                                check = True
                                break
                            
                            # if 절 아니더라도 갱신
                            answer = max(answer, sheep)
                            
                        # 더 나아갈 수 있는 경우
                        if not check:
                            allcase[i].append(tmp)

    return answer

```
## 풀이

스스로 풀다보니 코드가 복잡합니다.

풀이 방법은 0번 노드부터 갈 수 있는 모든 노드들을 체크해서 모든 경로를 가보는 것입니다.

예를 들어, 0번 노드에서 시작했다면 다음 가능한 노드는 1, 8입니다.

```
0
  01
  08
```

위와 같이 표현하겠습니다.

0번 노드에서 다음 노드를 들여쓰기를 하고 갈 수 있는 노드들을 표현했습니다.

이제 01과 08에서 또 다른 노드로 탐색을 하는 경우를 살펴보겠습니다.

01로 간 경우에는 012, 014, 018로 갈 수 있습니다.

이 문제에서는 바로 자기의 자식노드뿐만 아니라 다른 노드의 자식노드까지 갈 수 있는 것을 잘 생각해야합니다.

따라서 이를 제 표현으로 바꿔보면 아래와 같습니다.

```
0
  01
    012
    014
    018
  08
    081
    087
    089
```

이렇게 모든 경우를 찾도록 했습니다.

다시 설명하면 081은 0 -> 8 -> 1 순으로 이동한 것입니다.

이렇게 모든 노드를 찾고 양이 늑대보다 많은 경우를 따져서 최대한 양이 많게 하도록 하면 됩니다.

> 그러나, 밑에서 설명드리겠지만, 이 모든 경우를 전부 다 따지면 노드가 많아질수록 매우 급격하게 경우가 많아집니다.
> 따라서 노드를 탐색하다가 늑대가 많아진순간이 생긴 경우에 대해서는 거기서 멈추도록 했습니다.
> 하지만 설명할 때는 이를 제외하고 설명한 뒤에 추가하도록 하겠습니다.

이제 코드를 보고 설명드릴게요.

### 1) 상위 노드에서 하위 노드 갈 수 있는 경로 체크

미리 edgeInfo에 하나의 부모 노드에서 자식 노드로 갈 수 있는 길에 대해 리스트로 만들어둡니다.

그렇다면 이 리스트에 0번 노드에서는 1과 8로 갈 수 있으니, edgeInfo[0]에는 [1, 8]이 들어가있겠네요.

### 2) allcase에서 하나의 경우씩 뽑아옴

allcase는 위에서 설명드렸다시피 모든 경우에 대해 저장합니다.

예시로 보면, allcase[1]에는 [[0, 1], [0, 8]] 와 같이 들어가있습니다.

이는 위에서 설명드린 01, 08 이라고 보시면 됩니다.

> 참고로 "01", "08"로 표현하면 제가 설명드린것과 더 흡사해서 좋을 것으로 보입니다.
>
> 저 역시 "01", "08", "012", ... 등으로 처음에 시도했습니다.
>
> 그러나 코드를 전부 작성하고나서 계속 문제가 생겼는데 알고보니 노드 번호가 10번을 넘어가는 순간부터 문제가 생깁니다.
>
> 왜냐하면 "0110" 이 숫자가 0, 1, 1, 0 인지 0, 1, 10 인지 알 수 없기 때문이죠...

> 따라서 숫자를 리스트에 저장하여 [[0, 1], [0, 8]] 와 같이 저장합니다.

### 3) case에서 node 번호를 뽑아옴

case는 allcase([[0, 1], [0, 8]])에서 한 요소씩 뽑아옵니다.

따라서 처음 case는 [0, 1] 이겠네요.

이제 0번 노드에서 갈 수 있는 모든 노드들을 탐색하고 1번 노드에서 갈 수 있는 모든 노드들을 탐색해야합니다.

그래야 01 상황에 012, 014, 018 을 구할 수 있으니까요.

그래서 이때 edgeInfo를 사용합니다. edgeInfo에 n번 노드에 대한 정보가 들어있으니까요.

edgeInfo[node]를 하면 node번 노드 자식 노드를 보여줍니다.

이를 possibleNode라고 저장할게요.

갈 수 있는 노드들이라 생각하면 됩니다.

처음에는 0번 노드가 들어갈테니 possibleNode[0]는 [1, 8]이 나오겠네요.

그리고 possibleNode의 요소 개수는 0개 또는 1개 또는 2개 입니다. 자식노드의 개수니까요.

### 4) 다음에 갈 수 있는 노드들

possibleNode는 다음에 갈 수 있는 노드들이라고 했습니다.

즉 1번 노드에서는 2, 4를 갈 수 있습니다.

이제 2, 4를 진짜 갈 것인가를 정해주어야합니다.

`for nextNode in possibelNode:` 를 통해 확인해봅니다.

다음에 갈 노드는 이미 방문한 곳이면 안됩니다.

따라서 `if nextNode not in case:` 를 통해 없는 것을 확인하면 아래로 갑니다.

이렇게 하면 01 상황에 012, 014, 018이 가능하게 됩니다.

### 5) 늑대의 수 때문에 불가능한 경우 미리 제외

이제 아까 위에서 말씀드린 아예 불가능한 경우를 미리 제외하도록 하겠습니다.

1), 2), 3), 4) 는 갈 수 있는 노드들만을 택했기때문에 실제로 갈 수는 있는 경로입니다.

하지만 늑대의 수가 같거나 많아진다면 양이 전부 잡아먹히기 때문에 실제로는 가면 안되는 경로도 포함되어 있습니다.

따라서 5)에서 미리 제거합니다.

> 미리 제거하는 이유는 불필요한 경로에서 더 깊게 탐색하면 어차피 탐색안해도 되는 경로에 시간을 많이 뺏기게 됩니다.
> 예를 들어서 0124로 갔다고 가정하겠습니다.
> 0, 1은 양이지만 2, 4는 늑대입니다. 따라서 이미 4번의 이동에서 양과 늑대가 같아졌기 때문에 이미 잡아먹혔습니다.
> 따라서 012까지만 탐색해야합니다.
> 하지만 모든 경우를 탐색해버리면 아래와 같이 됩니다.
```
0
  01
    012
      0124
      --------------------
        01243
          012436
            ...
               ...
                 ...
                    ...
          012438
            ...
              ...
                ...
                  ...
```
> 점선 아래부터 노드들에 대해 엄청나게 탐색을 해야합니다.
> 0124에서 이미 불필요한 경로가 됐음에도 불구하구요.  
> 이에 탐색안해도 되는 것을 미리 제거합니다. 이해하실거라 생각합니다.

tmp에 현재 case를 저장합니다.

tmp = case는 얕은 복사가 됩니다. 따라서 피해줍니다.

> 얕은 복사  
> 리스트에 얕은 복사를 하게 되면, case 를 수정하면 tmp에 영향을 미치고, tmp를 수정해도 case에 영향을 미치게 됩니다.
> 이는 리스트 또는 배열에 주소값을 복사하는것이기 때문입니다.
>
> 제 포스팅중에서도 설명드렸고, 얕은 복사 또는 깊은 복사를 검색하시면 더 나은 설명이 많으니 넘어가겠습니다.

요소들을 하나씩 받아서 tmp에 저장합니다.

그리고 다음 갈 노드를 append 합니다.

이는 01 상태에서 2 또는 4 또는 8을 append 하는 것과 똑같습니다.

그래서 tmp는 012, 014, 018 상태가 되겠네요.

이제 이 tmp가 가능한 경우인지 확인합니다.

양과 늑대의 수를 계산합니다.

중간에 만약 양과 늑대의 수가 같다면, 이 경로는 여기서 종료할 것이기 때문에 양의 최대 수를 갱신합니다.

여기서 `# if 절 아니더라도 갱신`, 이 부분이 중요했습니다.

테스트 케이스를 입력값 : [0, 0], [[0, 1]] 와 같이 넣으면 기댓값이 2가 나와야합니다.

하지만 `# if 절 아니더라도 갱신` 이 부분을 넣지않으면 양과 늑대가 같아지지 않은 경로에 대해 추가를 하지 못합니다.

따라서 잘 추가해줍니다.

이제 아래에서 더 나아갈 수 있는 경우에는 tmp를 append 해주어서 다음 노드들에 더 탐색해줍니다.

이는 만약 tmp가 012 였다면, 0124 / 0128 등등 더 갈 수 있으므로 계속해서 추가하는 것입니다.

## 추가

테스트 케이스 4, 5번 실패 또는 런타임 오류

만약 테게 4, 5에서 막히시면, 다음을 확인해주세요.

저는 처음에 answer를 리스트로 만들고, 모든 경우에 대해 양의 수를 answer에 append 했습니다.

그리고 max(answer)를 통해 양의 최대값을 구하면 된다고 생각했는데, 이 때문에 테케 4, 5가 자꾸 실패하더라구요.

참고하세요

### 다른 블로그 코드

```python
def solution(info, edges):
    visited = [0] * len(info)
    answer = []
    
    def dfs(sheep, wolf):
        if sheep > wolf:
            answer.append(sheep)
        else:
            return 
        
        for p, c in edges:
            if visited[p] and not visited[c]:
                visited[c] = 1
                if info[c] == 0:
                    dfs(sheep+1, wolf)
                else:
                    dfs(sheep, wolf+1)
                visited[c] = 0

    # 루트 노드부터 시작
    visited[0] = 1
    dfs(1, 0)

    return max(answer)
```

DFS를 활용한 코드이다.

모든 edges에 대해 탐색하다가, 부모 노드는 방문했는데 자식 노드는 방문하지 않은 경우, 자식 노드에 방문해본다.

그리고 방문한 자식 노드는 방문 표시를 하고 방문한 자식 노드의 info 정보에 따라 sheep을 늘려 dfs를 다시 탐색하거나
wolf를 늘려 dfs를 다시 탐색하는 과정을 반복한다.

처음에 코드를 작성할 때 DFS를 생각하지 못한 것은 아니다. 나는 한 노드에서 다음 노드로 갈 수 있는 모든 노드들을 탐색하므로 BFS처럼 풀기는 했지만,

DFS로도 갈 수 있는 모든 노드들을 쭉 탐색하고 돌아오는 것도 생각해봤다.

하지만 그 생각속에서 내 문제점은 DFS로 쭉 탐색할 때 그 탐색에서 방문 표시를 어떻게 해야하냐 였다.

방문 표시를 visited를 만들어도 한 탐색을 끝내면 이 visited가 전부 한 탐색에서 만들어져 있으므로, 그럼 다른 탐색에서는 또 visited를 만들거나, visited에서 안에 또 리스트로 만들어서 관리를 해야하는가...

이 부분에서 머리가 복잡해 포기했다.

하지만 이 DFS 코드에서 DFS의 특성이 담겨있다고 생각하는 이유가 있다. 

지속적으로 DFS로 진입해서 탐색하므로 DFS를 빠져나올 때까지는 한 탐색에 머무른다. 

따라서 먼저 들어간 DFS에 작업이 다 끝나고 다른 DFS 탐색에 들어간다.

그래서 아래 코드에서 이 특성을 사용할 수 있다.

```python
for p, c in edges:
    if visited[p] and not visited[c]:
        visited[c] = 1
        if info[c] == 0:
            dfs(sheep+1, wolf)
        else:
            dfs(sheep, wolf+1)
        visited[c] = 0
```
위 코드에서 일부 따온 것이다.

맨 아래 코드를 보면 dfs 밑에 visited[c]를 다시 0으로 만들어준다.

잘 이해가 안갔는데, dfs가 끝나고 나와서 이를 다시 0으로 만들어주면 깊게 dfs를 끝나고 나오면서 방문해서 1로 만들어졌던 곳이

다시 0으로 바뀌며 visited를 다시 사용할 수 있게된다.

즉 visited를 하나 깊게 탐색하고나서, 전부 0으로 초기화가 되고, 다시 또 dfs로 진입해서 탐색하게 되므로

내가 우려했던 visited를 여러개 만들거나, 어떻게 초기화를 해야하는지에 대한 문제를 이곳에서 해결했다.

BFS처럼 한 깊이에 모든 것을 탐색하고 다음 깊이로 들어가는 것과 달리 DFS는 지속적으로 DFS로 진입하므로 한 탐색이 전부 끝나고 나서

다음 탐색이 이루어진다는 점을 지속적으로 생각해야겠다.

# 참고 사이트
[[프로그래머스 L3] 양과 늑대 (python)](https://velog.io/@thguss/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-L3-%EC%96%91%EA%B3%BC-%EB%8A%91%EB%8C%80-python)